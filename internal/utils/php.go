package utils

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

const phpIniFile = "/php.ini"

type PHPVersionDetails struct {
	Version    string
	BinaryPath string
	IniPath    string
	IsWorking  bool
	ErrorMsg   string
}

func CheckForSystemPHP() (bool, string, error) {
	globalPHPPath := filepath.Join(SystemBinDir, "php")
	
	if !FileExists(globalPHPPath) {
		return false, "", nil
	}
	
	info, err := os.Lstat(globalPHPPath)
	if err != nil {
		return false, "", fmt.Errorf("failed to check php binary: %v", err)
	}
	
	if info.Mode()&os.ModeSymlink != 0 {
		target, err := os.Readlink(globalPHPPath)
		if err != nil {
			return false, "", fmt.Errorf("failed to read symlink target: %v", err)
		}
		
		if strings.Contains(target, YerdBaseDir+"/") {
			return false, "", nil
		}
		
		return true, fmt.Sprintf("symlink to %s", target), nil
	}
	
	return true, "system binary", nil
}

func DetectSystemPHPInfo() (string, error) {
	cmd := filepath.Join(SystemBinDir, "php")
	output, err := ExecuteCommand(cmd, "-v")
	if err != nil {
		return "", fmt.Errorf("failed to get PHP version: %v", err)
	}
	
	lines := strings.Split(string(output), "\n")
	if len(lines) > 0 {
		return strings.TrimSpace(lines[0]), nil
	}
	
	return "Unknown PHP version", nil
}

func GetPHPBinaryPath(version string) (string, error) {
	possiblePaths := []string{
		YerdBinDir + "/php" + version,
		YerdPHPDir + "/php" + version + "/bin/php",
		SystemBinDir + "/php" + version,
		SystemBinDir + "/php",
		"/usr/bin/php" + version,
		"/usr/bin/php-" + version,
	}
	
	for _, path := range possiblePaths {
		if FileExists(path) {
			output, err := ExecuteCommand(path, "-v")
			if err == nil && strings.Contains(output, "PHP "+version) {
				return path, nil
			}
		}
	}
	
	return "", fmt.Errorf("PHP %s binary not found", version)
}

func GetPHPIniPath(version string) (string, error) {
	binaryPath, err := GetPHPBinaryPath(version)
	if err != nil {
		return "", err
	}
	
	output, err := ExecuteCommand(binaryPath, "--ini")
	if err != nil {
		return "", fmt.Errorf("failed to get ini info: %v", err)
	}
	
	lines := strings.Split(output, "\n")
	var configPath string
	var loadedIni string
	
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "Configuration File (php.ini) Path:") {
			configPath = strings.TrimSpace(strings.TrimPrefix(line, "Configuration File (php.ini) Path:"))
		} else if strings.HasPrefix(line, "Loaded Configuration File:") {
			loadedIni = strings.TrimSpace(strings.TrimPrefix(line, "Loaded Configuration File:"))
		}
	}
	
	if loadedIni != "" && loadedIni != "(none)" {
		return loadedIni, nil
	}
	
	if configPath != "" {
		potentialIniPath := configPath + phpIniFile
		if FileExists(potentialIniPath) {
			return potentialIniPath, nil
		}
		return fmt.Sprintf("%s (no php.ini)", configPath), nil
	}
	
	possibleIniPaths := []string{
		YerdEtcDir + "/php" + version + phpIniFile,
		YerdPHPDir + "/php" + version + "/lib/php.ini",
		YerdPHPDir + "/php" + version + "/etc/php.ini",
		"/etc/php/" + version + "/cli/php.ini",
		"/usr/local/etc/php/" + version + phpIniFile,
		"/opt/php/" + version + "/etc/php.ini",
	}
	
	for _, path := range possibleIniPaths {
		if FileExists(path) {
			return path, nil
		}
	}
	
	return "(none)", nil
}

func CreatePHPIniForVersion(version string) error {
	configDir := YerdEtcDir + "/php" + version
	iniPath := configDir + phpIniFile
	
	if FileExists(iniPath) {
		return fmt.Errorf("php.ini already exists at: %s", iniPath)
	}
	
	if err := os.MkdirAll(configDir, DirPermissions); err != nil {
		return fmt.Errorf("failed to create config directory: %v", err)
	}
	
	iniContent := generateDefaultPHPIni(version)
	
	if err := os.WriteFile(iniPath, []byte(iniContent), FilePermissions); err != nil {
		return fmt.Errorf("failed to create php.ini: %v", err)
	}
	
	return nil
}

func generateDefaultPHPIni(version string) string {
	extensionDir := detectExtensionDirectory(version)
	if extensionDir == "" {
		extensionDir = fmt.Sprintf("/opt/yerd/php/php%s/lib/php/extensions", version)
	}
	
	return fmt.Sprintf(`; Default PHP configuration for YERD-managed PHP %s
; Generated by YERD (A powerful, developer-friendly tool for managing PHP versions)
; Location: /opt/yerd/etc/php%s/php.ini

[PHP]
; Core Settings
engine = On
short_open_tag = Off
precision = 14
output_buffering = 4096
zlib.output_compression = Off
implicit_flush = Off
unserialize_callback_func =
serialize_precision = -1
disable_functions =
disable_classes =
zend.enable_gc = On
zend.exception_ignore_args = On
zend.exception_string_param_max_len = 0

; Resource Limits
max_execution_time = 30
max_input_time = 60
memory_limit = 128M

; Error handling and logging
error_reporting = E_ALL & ~E_DEPRECATED & ~E_STRICT
display_errors = Off
display_startup_errors = Off
log_errors = On
ignore_repeated_errors = Off
ignore_repeated_source = Off
report_memleaks = On

; Data Handling
variables_order = "GPCS"
request_order = "GP"
register_argc_argv = Off
auto_globals_jit = On
post_max_size = 8M
auto_prepend_file =
auto_append_file =
default_mimetype = "text/html"
default_charset = "UTF-8"

; File Uploads
file_uploads = On
upload_max_filesize = 2M
max_file_uploads = 20

; Fopen wrappers
allow_url_fopen = On
allow_url_include = Off
default_socket_timeout = 60

; Dynamic Extensions
extension_dir = "%s"

; Date
date.timezone = UTC

; Session
session.save_handler = files
session.use_strict_mode = 0
session.use_cookies = 1
session.use_only_cookies = 1
session.name = PHPSESSID
session.auto_start = 0
session.cookie_lifetime = 0
session.cookie_path = /
session.cookie_domain =
session.cookie_httponly =
session.cookie_samesite =
session.serialize_handler = php
session.gc_probability = 0
session.gc_divisor = 1000
session.gc_maxlifetime = 1440
session.referer_check =
session.cache_limiter = nocache
session.cache_expire = 180
session.use_trans_sid = 0
session.sid_length = 26
session.trans_sid_tags = "a=href,area=href,frame=src,form="
session.sid_bits_per_character = 5

; MySQLi
mysqli.max_persistent = -1
mysqli.allow_persistent = On
mysqli.max_links = -1
mysqli.default_port = 3306
mysqli.default_socket =
mysqli.default_host =
mysqli.default_user =
mysqli.default_pw =
mysqli.reconnect = Off

; bcmath
bcmath.scale = 0

; OpCache (if available)
; opcache.enable=1
; opcache.enable_cli=0
; opcache.memory_consumption=128
; opcache.interned_strings_buffer=8
; opcache.max_accelerated_files=4000
; opcache.revalidate_freq=2
; opcache.fast_shutdown=1
`, version, version, extensionDir)
}

func detectExtensionDirectory(version string) string {
	if extDir := getExtensionDirFromPHP(version); extDir != "" {
		return extDir
	}
	
	return findFallbackExtensionDir(version)
}

func getExtensionDirFromPHP(version string) string {
	binaryPath, err := GetPHPBinaryPath(version)
	if err != nil {
		return ""
	}
	
	output, err := ExecuteCommand(binaryPath, "-r", "echo ini_get('extension_dir');")
	if err != nil {
		return ""
	}
	
	extDir := strings.TrimSpace(output)
	if extDir != "" && FileExists(extDir) {
		return extDir
	}
	
	return ""
}

func findFallbackExtensionDir(version string) string {
	installPath := YerdPHPDir + "/php" + version
	possibleExtDirs := []string{
		installPath + "/lib/php/extensions",
		installPath + "/lib64/php/extensions", 
		installPath + "/lib/extensions",
	}
	
	for _, baseDir := range possibleExtDirs {
		if extDir := searchExtensionSubDir(baseDir); extDir != "" {
			return extDir
		}
	}
	
	return ""
}

func searchExtensionSubDir(baseDir string) string {
	if !FileExists(baseDir) {
		return ""
	}
	
	output, err := ExecuteCommand("find", baseDir, "-maxdepth", "1", "-type", "d", "-name", "*")
	if err != nil {
		return baseDir
	}
	
	lines := strings.Split(strings.TrimSpace(output), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line != baseDir && FileExists(line) {
			return line
		}
	}
	
	return baseDir
}

func NormalizePHPVersion(version string) string {
	if len(version) > 3 {
		prefix := strings.ToLower(version[:3])
		if prefix == "php" {
			return version[3:]
		}
	}
	return version
}